
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/indent */

import { $$equals } from '@benzed/immutable/lib'

type Intersect<T extends any[]> = T extends [infer T1, ...infer TR] ? T1 & Intersect<TR> : unknown
type Merge<T extends any[]> = { [K in keyof Intersect<T>]: Intersect<T>[K] }
type Shape = { [key: string]: any }

enum Flags {
    Readonly,
    Optional
}

type HasFlag<F extends Flags[], T extends Flags, Y, N = never> = F extends [infer T1, ...infer TR]
    ? T1 extends T

    /**/ ? Y
    /**/ : TR extends Flags[]

        /**/ ? HasFlag<TR, T, Y, N>
        /**/ : N

    : N

type IsOptionalReadonly<F extends Flags[], Y, N = never> =
    F extends [Flags.Readonly, Flags.Optional]
    /**/ ? Y
    /**/ : F extends [Flags.Optional, Flags.Readonly]
        /**/ ? Y
        /**/ : N

type IsReadonly<F extends Flags[], Y, N = never> = F extends [Flags.Readonly]
    ? Y
    : N

type IsOptional<F extends Flags[], Y, N = never> = F extends [Flags.Optional]
    ? Y
    : N

type HasReadonly<F extends Flags[], Y, N = never> = HasFlag<F, Flags.Readonly, Y, N>

type HasOptional<F extends Flags[], Y, N = never> = HasFlag<F, Flags.Optional, Y, N>

type ChainSchema<S extends Schema<any, any>, T, F extends Flags[]> = S extends StringSchema<any>
    ? StringSchema<F>
    : S extends NumberSchema<any>
    /**/ ? NumberSchema<F>
    /**/ : S extends ShapeSchema<any, any>
        /**/ ? ShapeSchema<T, F>
        /**/ : Schema<T, F>

abstract class Schema<T, F extends Flags[]> {

    public readonly flags: F

    private readonly _default!: T

    public constructor (...flags: F) {
        this.flags = flags
        this.optional = null as any
        this.readonly = null as any
    }

    public readonly optional: HasOptional<
        F,
        never,
        () => ChainSchema<this, T, [...F, Flags.Optional]>
    >

    public readonly readonly: HasReadonly<
        F,
        never,
        () => ChainSchema<this, T, [...F, Flags.Readonly]>
    >

}

type SchemaFlags<S> = S extends Schema<any, infer F> ? F : never

type SchemaType<S> = S extends Schema<infer T, any> ? T : never

type Infer<I, F extends Flags[] = []> = I extends Schema<infer T, infer F2>
    ? InferOptional<F2, T>
    : I extends Shape
    ? InferShape<I, F>
    : I

type InferOptional<F extends Flags[], T> =
    HasOptional<
        F,
        Infer<T> | undefined,
        Infer<T>
    >

type InferShape<T extends Shape, F extends Flags[]> =
    Merge<[
        { readonly [K in keyof T as IsReadonly<SchemaFlags<T[K]>, K>]: Infer<T[K], F> },
        { readonly [K in keyof T as IsOptionalReadonly<SchemaFlags<T[K]>, K>]?: Infer<T[K], F> },
        { [K in keyof T as IsOptional<SchemaFlags<T[K]>, K>]?: Infer<T[K], F> },
        { [K in keyof T as SchemaFlags<T[K]> extends [] ? K : never]: Infer<T[K], F> }
    ]>

class ShapeSchema<T extends Shape, F extends Flags[]> extends Schema<T, F> { }

class NumberSchema<F extends Flags[]> extends Schema<number, F> { }

class StringSchema<F extends Flags[]> extends Schema<string, F> { }

interface SchemaInterface {
    <T extends Shape>(input: T): ShapeSchema<T, []>

    shape<T extends Shape>(input: T): ShapeSchema<T, []>

    number(): NumberSchema<[]>

    string(): StringSchema<[]>
}

const $ = null as unknown as SchemaInterface

const AddressSchema = $({
    street: $.string().readonly(),
    apartment: $.string().readonly().optional(),
    country: $.string().readonly(),
    code: $({
        prefix: $.number(),
        postfix: $.number(),
        code: $.string()
    }).readonly()
})

type Address = Infer<typeof AddressSchema>